## 题目
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5

## 思路
先要理解中位数的概念：将一个集合分为个数相等的两部分，左边的部分的数小于右面部分的数。
两个集合A、B， A使用i分隔为两部分，A[0]...A[i] , A[i+1]...A[m]，B使用j分隔，B[0]...B[j] , B[j+1]...B[n]，则合并后的中位数满足：
i+j = m-i + n-j  ->   j= (m+n)/2 - i -> j = (m+n+1)/2 - i (+1的目的见下)
A[i] <= B[j+1]
B[j] <= A[i+1]

首先加一的目的是在奇数时将中位数放在左边，然后看一看为什么放到左边。看代码中有return maxLeft，中位数放到左边可以顺利返回，而放到右边会发生什么？这行代码需要换为return minRight = min(A[i],B[j])，但是i和j并不是始终都会在合法范围内，以{}{1}为例，一定不能出现A[i]。综上，加一是为了防止数组越界。


使用j的表达式替换下面两个不等式，求得满足条件的i即可，二分查找
